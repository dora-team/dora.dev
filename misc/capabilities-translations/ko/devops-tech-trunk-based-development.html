<html devsite><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
    <title>DevOps 테크: 트렁크 기반 개발</title>
    <meta name="book_path" value="/architecture/devops/_book.yaml"/>
    <meta name="project_path" value="/architecture/devops/_project.yaml"/>
    <meta name="translation_service" value="machine_translation_light_post_edit"/>
  </head>
  <body>

<aside class="note"><strong>Note:</strong><span> <em>트렁크 기반 개발</em>은 소프트웨어 제공 및 조직 성과 향상을 가져오는 기능 집합 중 하나입니다.
이러한 기능은 성과 향상을 이끌어내는 관례와 기능을 독립적이면서 학술적으로 심층 연구하는 <a href="https://www.devops-research.com/research.html">DORA State of DevOps 연구 프로그램</a>을 통해 개발되었습니다. 자세한 내용은 <a href="/devops">DevOps 리소스</a>를 참조하세요.</span></aside>
<p>개발자팀이 버전 제어를 사용하여 함께 작업하는 데에는 두 가지 주요 패턴이 있습니다. 하나는 <em>기능 분기</em>를 사용하는 것입니다. 이 패턴에서는 개발자 또는 개발자 그룹이 트렁크(<em>기본</em> 또는 <em>기본 라인</em>이라고도 함)에서 분기를 만든 다음, 빌드하는 기능이 완료될 때까지 해당 분기에서 개별적으로 작업합니다. 팀에서 기능이 제대로 준비가 되었다고 판단하면 기능 분기를 트렁크에 병합합니다.</p>

<p>두 번째 패턴은 <em>트렁크 기반 개발</em>이라고 합니다. 이 패턴에서는 각 개발자가 작업을 <a href="/architecture/devops/devops-process-working-in-small-batches" track-type="solution" track-name="internalLink" track-metadata-position="body">소규모 배치</a>로 나눈 다음 해당 작업을 하루 한번 이상(여러 번 가능) 트렁크에 병합합니다. 이러한 접근 방식의 주요 차이점은 범위입니다. 기능 분기에는 일반적으로 여러 개발자가 관여하며 며칠, 심지어 몇 주가 소요됩니다. 반대로 트렁크 기반 개발에서는 많은 개발자들이 개별 변경사항을 트렁크에 자주 병합하므로 분기가 일반적으로 몇 시간 이상 지속되지 않습니다.</p>

<p>다음 다이어그램은 일반적인 트렁크 기반 개발 타임라인을 보여줍니다.</p>

<p><img src="/static/architecture/devops/images/devops-tech-trunk-based-development-typical-trunk-timeline.svg" alt="버전 1.0에서 버전 1.1의 트렁크로 병합된 버그 수정을 보여주는 버전 1.0 및 1.1의 타임라인"/></p>

<p>트렁크 기반 개발에서 개발자는 코드를 트렁크에 직접 푸시합니다. 출시 분기에서 변경된 사항(출시 준비가 된 코드의 스냅샷)은 일반적으로 가능한 빨리 트렁크에 다시 병합됩니다(아래쪽 화살표로 표시됨). 이 접근방식에서는 버그 수정을 선별하여 출시 분기에 병합(위쪽 화살표로 표시됨)해야 하는 경우가 있지만, 이러한 경우는 트렁크에서 새로운 기능의 개발만큼 자주 발생하지 않습니다. 하루에 여러 번 출시되는 경우 변경사항을 트렁크에 직접 푸시하여 배포할 수 있으므로 출시 분기가 전혀 필요하지 않습니다.
트렁크 기반 접근방식의 주요 이점은 개발 라인을 줄이고 소규모 병합을 빈번하게 수행하여 이벤트를 병합하는 데 따른 복잡성이 감소하고 코드를 최신 상태로 유지할 수 있다는 것입니다.</p>

<p>반대로 다음 다이어그램은 트렁크를 기반으로 하지 않은 일반적인 개발 스타일을 보여줍니다.</p>

<p><img src="/static/architecture/devops/images/devops-tech-trunk-based-development-typical-non-trunk-timeline.svg" alt="병합 충돌로 제품 출시가 지연될 수 있는 복잡한 병합 경로와 여러 지점을 보여주는 여러 장기 지속 분기의 타임라인"/></p>

<p>이 접근방식에서는 개발자가 장기 지속 분기를 변경합니다. 이러한 변경에는 트렁크 기반 개발에 비해 더 복잡한 대규모 병합 이벤트가 필요합니다. 또한 대규모 병합 시 종종 버그 또는 회귀가 발생하므로 이 접근방식에서는 소프트웨어를 작동 상태로 유지하기 위한 추가적인 안정화 작업과 '코드 잠금' 또는 '코드 고정' 기간이 필요합니다. 결과적으로 병합 후 코드를 철저하게 테스트하고 종종 버그를 수정해야 합니다.</p>

<h2 id="how_to_implement_trunk-based_development" data-text="트렁크 기반 개발 구현 방법">트렁크 기반 개발 구현 방법</h2>

<p>트렁크 기반 개발은 <a href="/architecture/devops/devops-tech-continuous-integration" track-type="solution" track-name="internalLink" track-metadata-position="body">지속적 통합</a>을 위한 필수사항입니다.
지속적 통합(CI)은 트렁크 기반 개발 작업과 시스템의 상시 작동을 유지하기 위해 트렁크로 커밋 후 자동으로 신속하게 실행되는 일련의 테스트를 유지관리하는 작업의 결합입니다.</p>

<p>지속적 통합의 주요 특징은 소규모 코드 배치를 자주 통합하여 긴 통합 및 안정화 단계를 없애는 것입니다. 이렇게 하면 개발자는 수행 중인 작업에 대해 의사소통할 수 있고 통합 시 다른 개발자와 테스터에게 상당한 작업을 유발할 수 있는 대규모 병합을 피할 수 있습니다.</p>

<p>CI 패러다임에서 빌드 프로세스를 <em>그린</em>, 즉 준비 및 실행 상태로 유지하는 것은 개발자의 책임입니다. 다시 말해 CI 프로세스가 실패하는 경우 개발자는 수행 중인 작업을 중단하고 문제를 즉시 수정하거나 즉시 수정할 수 없다면 변경사항을 되돌려야 합니다.</p>

<p>트렁크 기반 개발을 수행하려면 개발자가 <a href="/architecture/devops/devops-process-working-in-small-batches" track-type="solution" track-name="internalLink" track-metadata-position="body">작업을 소규모 배치로 나누는</a> 방법을 이해해야 합니다.
이는 이런 식으로 작업하는 데 익숙하지 않은 개발자에게 큰 변화입니다.</p>

<p><a href="https://services.google.com/fh/files/misc/state-of-devops-2016.pdf#page=31" target="external" track-type="solution" track-name="externalLink" track-metadata-position="body">2016년</a>(PDF) 및 <a href="https://services.google.com/fh/files/misc/state-of-devops-2017.pdf#page=40" target="external" track-type="solution" track-name="externalLink" track-metadata-position="body">2017년</a>(PDF)의 DORA(DevOps Research and Assessment) 데이터 분석 결과 팀에서 다음 관행을 따를 경우 더 높은 수준의 소프트웨어 배포 및 운영 성능(배포 속도, 안정성, 가용성)을 실현할 수 있음을 보여줍니다.</p>

<ul>
<li>애플리케이션의 코드 저장소에 3개 이하의 활성 분기를 유지합니다.</li>
<li>하루 한번 이상 분기를 트렁크에 병합합니다.</li>
<li>코드를 고정하지 않으면 통합 단계를 수행하지 않습니다.</li>
</ul>

<h2 id="common_pitfalls" data-text="일반적인 문제">일반적인 문제</h2>

<p>트렁크 기반 개발을 완전히 채택하는 데 장애가 되는 몇 가지 주요 문제는 다음과 같습니다.</p>

<ul>
<li><p><strong>코드-검토 절차가 매우 복잡합니다</strong>. 많은 조직에는 변경사항을 트렁크에 병합하기 전에 여러 승인 단계가 필요한 복잡한 코드 검토 절차가 있습니다. 코드 검토에 많은 노력이 필요하고 오랜 시간이 걸리는 경우 개발자는 소규모 배치 작업을 피하고 많은 변경사항을 일괄 처리하게 됩니다. 이렇게 되면 검토자가 복잡성으로 인해 대규모 코드 검토를 미루게 되는 하향곡선이 나타나게 됩니다.</p>

<p>결과적으로 개발자가 병합 요청을 피하게 되므로 병합 요청이 종종 약화됩니다. 검사를 통해 대규모 변경이 시스템에 미치는 영향을 추론하기가 쉽지 않으므로 검토자가 결함을 찾기 어려워지고 트렁크 기반 개발의 이점이 줄어들게 됩니다.</p></li>
<li><p><strong>코드 검토가 비동기적으로 수행됩니다</strong>. 팀에서 페어 프로그래밍을 수행하는 경우 다른 사람이 코드를 이미 검토한 것입니다. 추가 검토가 필요한 경우 동기적으로 수행해야 합니다. 즉, 개발자가 코드를 커밋할 준비가 되면 다른 팀원에게 코드를 즉시 검토하도록 요청해야 합니다. 예를 들어 요청을 도구에 제출한 다음 검토를 기다리는 동안 새로운 작업을 시작하는 것과 같이 비동기적인 검토를 요청하지 않아야 합니다. 병합이 지연될수록 병합 충돌 및 관련 문제가 발생할 가능성이 높습니다. 동기식 검토를 구현하려면 다른 작업보다 서로의 코드를 우선적으로 검토하도록 하는 팀의 합의가 있어야 합니다.</p></li>
<li><p><strong>코드 커밋 전에 자동 테스트를 실행하지 않습니다</strong>. 트렁크가 작동 상태를 유지하려면 필수적으로 커밋 전에 코드 변경사항에 대해 테스트를 실행해야 합니다. 이는 개발 워크스테이션에서 수행할 수 있으며, 많은 도구에서 로컬 변경사항에 대해 원격 테스트를 실행한 다음 테스트에 통과했을 때 자동으로 커밋하는 기능을 제공합니다. 개발자가 복잡한 절차 없이 코드를 트렁크에 삽입할 수 있다는 것을 알게 되면 결과적으로 소규모 코드 변경이 발생하므로 이해, 검토, 테스트가 용이해지고 프로덕션으로 손쉽게 이동할 수 있게 됩니다.</p></li>
</ul>

<h2 id="ways_to_improve_trunk-based_development" data-text="트렁크 기반 개발 개선 방법">트렁크 기반 개발 개선 방법</h2>

<p>앞에서 논의한 바와 같이 트렁크 기반 개발을 개선하기 위해 구현할 수 있는 몇 가지 관행이 있습니다.</p>

<ul>
<li><strong>소규모 배치로 개발합니다</strong>. 트렁크 기반 개발의 가장 중요한 요인 중 하나는 <a href="/architecture/devops/devops-process-working-in-small-batches" track-type="solution" track-name="internalLink" track-metadata-position="body">소규모 배치로 개발</a>하는 방법을 학습하는 것입니다.
이를 위해서는 개발팀에 대한 교육과 조직의 지원이 필요합니다.</li>
<li><strong>동기식 코드 검토를 수행합니다.</strong> 앞서 논의한 대로, 동기식 코드 검토를 진행하거나 개발자가 코드 검토를 우선적으로 지정하도록 하면 변경사항이 트렁크에 병합되기까지 오랜 시간을 대기할 필요가 없습니다.</li>
<li><strong>포괄적인 자동 테스트를 구현합니다</strong>. 포괄적이고 유의미한 <a href="/architecture/devops/devops-tech-test-automation" track-type="solution" track-name="internalLink" track-metadata-position="body">자동화된 단위 테스트</a> 모음이 있어야 하고 커밋 전에 실행되어야 합니다. 예를 들어 GitHub를 사용하는 경우 모든 테스트를 통과했을 때 pull 요청 병합만 허용하도록 <a href="https://help.github.com/en/articles/about-protected-branches" target="github" track-type="solution" track-name="gitHubLink" track-metadata-position="body" class="external">분기를 보호</a>할 수 있습니다. <a href="/build/docs/run-builds-with-github-checks" track-type="solution" track-name="internalLink" track-metadata-position="body">GitHub 검사를 사용하여 빌드 실행</a> 가이드에서는 <a href="https://developer.github.com/v3/checks/" target="github" track-type="solution" track-name="gitHubLink" track-metadata-position="body" class="external">GitHub 검사</a>와 <a href="/build" track-type="solution" track-name="internalLink" track-metadata-position="body">Cloud Build</a>를 통합하는 방법을 보여줍니다.</li>
<li><strong>빠르게 빌드합니다</strong>. 빌드 및 테스트 프로세스는 <a href="https://www.infoq.com/presentations/Crazy-Fast-Build-Times-or-When-10-Seconds-Starts-to-Make-You-Nervous/" target="external" track-type="solution" track-name="externalLink" track-metadata-position="body" class="external">몇 분</a> 내에 실행되어야 합니다.
그렇게 할 수 없다면 시스템 <a href="/architecture/devops/devops-tech-architecture" track-type="solution" track-name="internalLink" track-metadata-position="body">아키텍처</a>에 개선할 여지가 있다는 것을 의미합니다.</li>
<li><strong>후원자 및 멘토로 구성된 핵심 그룹을 만듭니다</strong>. 트렁크 기반 개발은 많은 개발자에게 상당한 변화이며 일부 저항이 발생할 수 있습니다. 많은 개발자들은 이런 방식으로 작업하는 것을 쉽게 생각하지 못합니다. 좋은 방법은 이런 방식으로 작업해 본 경험이 있는 개발자를 찾아서 다른 개발자를 코칭하도록 하는 것입니다. 또한 일부 팀을 트렁크 기반 스타일로 작업하도록 전환하는 것이 중요합니다. 이렇게 하려면 우선 트렁크 기반 개발 경험이 있는 개발자를 모아서 최소 1개의 팀이 트렁크 기반 개발 방법을 따르도록 하는 것입니다. 그런 다음 이 방법을 따르는 팀이 예상대로 업무를 수행하고 있다는 확신이 들 때 다른 팀도 이러한 스타일로 전환할 수 있습니다.</li>
</ul>

<h2 id="ways_to_measure_trunk-based_development" data-text="트렁크 기반 개발 측정 방법">트렁크 기반 개발 측정 방법</h2>

<p>다음을 수행하여 트렁크 기반 개발의 유효성을 측정할 수 있습니다.</p>

<table>
  <colgroup>
    <col width="30%" />
    <col width="35%" />
    <col width="35%" />
  </colgroup>
<thead>
<tr>
<th>테스트 요소</th>
<th>측정 항목</th>
<th>목표</th>
</tr>
</thead>
<tbody>
<tr>
<td>애플리케이션 코드 저장소의 활성 분기.</td>
<td>애플리케이션 저장소의 버전 제어 시스템에 있는 활성 분기 수를 측정하고 이 수를 모든 팀원에게 보이도록 합니다. 그런 다음 목표 상태에 대한 진행상황을 추적합니다.</td>
<td>3개 이하의 활성 분기.</td>
</tr>
<tr>
<td>코드 고정 기간.</td>
<td>팀이 보유한 코드 고정 수와 지속 기간을 측정합니다. 이러한 측정을 통해 병합 충돌, 코드 고정, 안정화 등에 소요된 시간도 분류할 수 있습니다.</td>
<td>코드를 제출할 수 없는 경우 코드 고정 없음.</td>
</tr>
<tr>
<td>분기 및 포크를 트렁크에 병합하는 빈도.</td>
<td>병합되는 각 분기의 바이너리(예/아니요) 값을 측정하거나 매일 병합되는 분기 및 포크의 비율을 측정합니다.</td>
<td>하루 한번 이상 병합.</td>
</tr>
<tr>
<td>코드 변경을 승인하는 데 소요된 시간 확인.</td>
<td>코드 검토를 비동기식으로 수행하는 경우 변경 요청을 승인하는 데 걸리는 평균 시간을 측정하고 평균보다 더 오래 걸리는 요청에 주의합니다.</td>
<td>코드 검토를 개발의 일부로 수행하는 동기식 작업으로 만드는 방법 찾기.</td>
</tr>
</tbody>
</table>

<h2 id="whats_next" data-text="다음 단계">다음 단계</h2>

<ul>
<li>다른 문서 및 리소스 링크는 <a href="/devops" track-type="solution" track-name="internalLink" track-metadata-position="body">DevOps 페이지</a>를 참조하세요.</li>
<li><a href="https://github.com/marketplace/google-cloud-build" target="github" track-type="solution" track-name="gitHubLink" track-metadata-position="body" class="external">Cloud Build 앱</a>을 사용하여 Google Cloud를 GitHub에 연결하는 방법을 알아 보려면 <a href="/build/docs/run-builds-with-github-checks" track-type="solution" track-name="internalLink" track-metadata-position="body">GitHub 검사로 빌드 실행</a>을 참조하세요.</li>
<li><p><a href="https://martinfowler.com/bliki/FeatureBranch.html" target="external" track-type="solution" track-name="externalLink" track-metadata-position="body" class="external">기능 분기</a>에서 Martin Fowler의 기사를 참조하세요.</p></li>
<li><p><a href="https://continuousdelivery.com/2011/07/on-dvcs-continuous-integration-and-feature-branches/" target="external" track-type="solution" track-name="externalLink" track-metadata-position="body" class="external">DVCS 및 기능 브랜치</a>에서 Jez Humble의 게시물을 참조하세요.</p></li>
<li><p>Paul Hammant의 <a href="https://trunkbaseddevelopment.com/" target="external" track-type="solution" track-name="externalLink" track-metadata-position="body" class="external">트렁크 기반 개발 포털</a>을 참조하세요.</p></li>
<li><p>DevOps <a href="https://www.devops-research.com/research.html">연구 프로그램</a>을 살펴보세요.</p></li>
<li><p><a href="https://www.devops-research.com/quickcheck.html">DevOps 빠른 점검</a>을 사용하여 업계와 비교되는 자신의 현재 상태를 파악하세요.</p></li>
</ul>

</body></html>