<html devsite><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
    <title>DevOps 기술: 코드 유지보수성</title>
    <meta name="book_path" value="/architecture/devops/_book.yaml"/>
    <meta name="project_path" value="/architecture/devops/_project.yaml"/>
    <meta name="translation_service" value="machine_translation_light_post_edit"/>
  </head>
  <body>

<aside class="note"><strong>참고:</strong><span> <em>코드 유지관리</em>는 소프트웨어 제공 및 조직 성과 향상을 가져오는 기능 집합 중 하나입니다. 이러한 기능은 성과 향상을 이끌어내는 관례와 기능을 독립적이자 학술적으로 심층 연구하는 <a href="https://www.devops-research.com/research.html">DORA State of DevOps 연구 프로그램</a>을 통해 개발되었습니다. 자세한 내용은 <a href="/devops">DevOps 리소스</a>를 참조하세요.</span></aside>
<p>우리가 빌드하는 시스템을 실행하기 위해서는 <a href="https://www.businessinsider.com/how-many-lines-of-code-it-takes-to-run-different-software-2017-2" target="external" track-type="article" track-name="externalLink" track-metadata-position="body">많은 코드</a>가 사용됩니다. Android 운영체제는 1,200만~1,500만 줄의 코드로 실행됩니다. Google의 모놀리식 코드 저장소에는 10억 줄 이상의 코드가 포함되어 있으며, 일반적인 스마트폰 앱에도 50,000줄 정도의 코드가 포함됩니다.</p>

<p><a href="/devops" track-type="article" track-name="internalLink" track-metadata-position="body">DevOps Research and Assessment(DORA)</a> 연구소의 2019 State of DevOps Report에 따르면 팀에서 코드를 효율적으로 유지보수할 수 있는 능력이 <a href="/architecture/devops/devops-tech-continuous-delivery" track-type="article" track-name="internalLink" track-metadata-position="body">지속적 배포</a>의 성공에 긍정적으로 기여하는 여러 기술 방식 중 하나입니다.</p>

<p>팀의 코드 유지보수성이 뛰어나면 다음과 같은 이점을 얻을 수 있습니다.</p>

<ul>
<li>팀에서 코드베이스에서 예시를 찾아내고, 다른 사람의 코드를 재사용하고, 필요에 따라 다른 팀에서 관리되는 코드를 변경하는 것까지 쉽게 수행할 수 있습니다.</li>
<li>팀에서 프로젝트에 새로운 종속 항목을 추가하고, 새로운 종속 항목 버전으로 마이그레이션하는 과정을 쉽게 수행할 수 있습니다.</li>
<li>팀의 종속 항목이 안정화되고 코드를 거의 훼손하지 않습니다.</li>
</ul>

<p>이러한 조사 결과에 따라, 개발자가 전체 조직의 코드베이스에서 필요한 코드를 쉽게 찾고, 재사용하고, 변경할 수 있도록 지원하고 종속 항목 관리를 위한 절차 및 도구를 구현하는 것의 중요성이 강조됩니다.</p>

<p>코드 유지보수성은 다른 팀의 코드를 검색, 재사용, 변경할 수 있는 능력에 의존하기 때문에 조직 전반의 조정 능력이 요구되는 기능입니다. 코드베이스 및 조직 규모가 클 때 효율적으로 종속 항목을 관리하는 것은 해결하기 어려운 과제가 되는 경우가 많습니다. 종속 항목 관련 문제를 방지하거나 코드 변경에 따른 결과를 조명하는 데 도움이 되는 도구를 제공하면 모든 엔지니어의 디자인 결정 및 코드 품질을 향상시키고, 따라서 이들의 업무 수행 속도를 높이고 더 안정적이고, 더 믿을 수 있는 소프트웨어를 만들 수 있게 해줍니다.</p>

<h2 id="how_to_implement_code_maintainability" data-text="코드 유지보수성 구현 방법">코드 유지보수성 구현 방법</h2>

<p>구현 측면에서는 소스 코드 관리와 종속 항목 관리의 두 가지 문제를 한 번에 해결하는 솔루션이 가능하더라도(Google에서 사용되는 모놀리식 저장소 또는 <em>monorepo</em> 패턴), 이 두 가지 문제를 개별적으로 처리하는 것이 좋습니다.</p>

<p>먼저 소스 코드 관리입니다. 모든 사람이 코드베이스에서 코드를 쉽게 검색, 재사용 및 변경하도록 지원하면 다음과 같은 이점을 얻을 수 있습니다.</p>

<ul>
<li><strong>더 빠른 제공:</strong> 소프트웨어를 빠르게 제공하기 위해서는 팀원들이 서로 코드를 보고 변경을 제안할 수 있어야 합니다. 이를 가능한 한 쉽게 수행할 수 있으면 조직 전반으로 지식을 전달하고, 작업 수행을 위해 코드베이스의 다른 부분을 쉽게 변경할 수 있습니다.</li>
<li><strong>더 뛰어난 수준의 안정성 및 가용성:</strong> 사고 발생 시에는 코드베이스의 어떤 부분도 신속하게 검색하고 변경을 제안할 수 있어야 합니다.</li>
<li><strong>더 높은 코드 품질:</strong> 내부 품질 향상을 위해 코드를 리팩터링하기 위해서는 코드베이스의 여러 부분을 변경해야 할 경우가 많습니다. 이러한 과정이 어려우면 사람들이 리팩터링을 수행할 가능성이 줄어들고, 이를 수행하기 위한 비용이 증가합니다. Google을 비롯한 일부 조직은 개인이 코드베이스를 확인하여 유지보수 수준의 항목을 수정할 수 있는 팀 간 코드 유지보수 프로젝트를 운영합니다. 이를 위해서는 조직 내에서 코드에 쉽게 액세스하고 코드를 변경할 수 있어야 합니다.</li>
</ul>

<p>예시를 검색하고 다른 사람의 코드를 재사용하기 위해서는 전체 조직의 소스 코드를 쉽게 액세스하고 검색할 수 있어야 합니다. 이러한 요구 사항을 구현하기 위한 가장 간단한 방법은 코드가 플랫폼 내에서 여러 저장소로 분할되어 있더라도 전체 조직 코드에 대해 단일 버전 제어 플랫폼을 사용하는 것입니다. 사용되는 버전 제어 플랫폼이 분할될수록 코드를 찾는 것이 더 어렵습니다.</p>

<p>일부 조직은 알 필요가 있는 사람만 코드베이스의 특정 부분에 액세스할 수 있도록 코드베이스 일부를 잠가두길 원할 것입니다. Google도 그러한 조직 중 하나입니다. 이상적으로 이것은 규칙보다는 예외로 적용되어야 하며, 기밀 소스 코드의 노출 영역을 최소화하도록 소프트웨어를 설계해야 합니다. 많은 경우에는 버전 제어 시스템의 액세스 제어 메커니즘을 사용하여 기밀 코드를 논리적으로 분리하는 것만으로 충분합니다.</p>

<p>또한 다른 팀에서 관리되는 코드를 변경하는 것도 가능해야 합니다. 일반적으로 이러한 변경을 위해서는 문제의 코드에 대한 관리 책임이 있는 팀의 승인이 필요합니다. 버전 제어로 분기가 생성되고 승인 시 분기 병합이 이뤄지는 pull 요청과 같은 메커니즘은 다른 팀의 변경 제안 허용으로 인한 문제를 최소화하고, <a href="/architecture/devops/devops-process-streamlining-change-approval" track-type="article" track-name="internalLink" track-metadata-position="body">미승인 변경</a>을 방지하고, 책임 분리와 같은 정보 보안 제어를 강화합니다.</p>

<p>그런 후 다음 종속 항목을 고려하세요. 팀의 종속 항목 추가 및 업데이트가 쉽도록 만들고 안정성과 코드 미손상을 보장한다는 것은 다음과 같은 의미를 갖습니다.</p>

<ul>
<li><strong>보안 향상:</strong> 종속 항목 사용 기간이 늘어나면 취약점이 발견될 가능성도 늘어납니다. 특히 취약점을 발견하고 패치를 적용한 다음 종속 항목을 최신 상태로 유지하는 것이 중요합니다.</li>
<li><strong>더 빠른 제공:</strong> 다른 팀 또는 조직에서 개발된 라이브러리를 사용하면 해당 작업을 위해 직접 코드를 작성할 필요가 없습니다.
종속 항목의 안정성과 코드 미손상을 보장하는 메커니즘을 마련한 경우 코딩에 더 많은 시간을 투자하고 유지보수에 드는 시간을 줄일 수 있습니다.</li>
</ul>

<p>종속 항목 관리는 소프트웨어 개발 팀의 공통적인 과제입니다.
종속 항목을 최신 상태로 유지하고 애플리케이션 간에 일관적으로 관리하는 것은 복잡하고 시간과 비용이 많이 듭니다. 많은 조직들이 이 작업에 적절한 리소스를 할당하지 못하고 있으며, 부적절한 프로세스 및 도구 지원으로 문제가 더욱 배가됩니다. 그 결과 종속 항목에서 취약점이 발견되었을 때 상당한 보안 위험이 발생할 수 있으며, 이를 사용하는 애플리케이션을 업데이트해야 합니다.</p>

<p>자동화된 <a href="/architecture/devops/devops-tech-continuous-integration" track-type="article" track-name="internalLink" track-metadata-position="body">지속적 통합</a>(CI) 및 <a href="/architecture/devops/devops-tech-test-automation" track-type="article" track-name="internalLink" track-metadata-position="body">테스트</a>를 통해 새 버전의 종속 항목에 브레이킹 체인지가 포함되었는지 여부를 확인하고, 이를 사용하는 시스템에서 사용되는 종속 항목 버전을 빠르고 간단하게 수정하는 등 팀이 잘 알려진 종속 항목 버전을 쉽게 사용하고 이를 빠르게 업그레이드하도록 지원하는 프로세스 및 도구를 채택하고 발전시키는 것이 중요합니다.</p>

<p>소프트웨어에 종속 항목을 포함하기 위해서는 일반적으로 벤더링 및 선언적 매니페스트의 두 가지 모델이 사용됩니다. 벤더링에서는 애플리케이션과 함께 모든 종속 항목의 소스 코드 또는 바이너리를 버전 제어에서 확인합니다. 또한 가장 현대적인 플랫폼에는 버전 제어로 확인되는 선언적 매니페스트 파일에 지정된 종속 항목을 관리하는 종속 항목 관리 도구가 포함되어 있습니다(예: Python의 pip, Node.js의 npm, R의 CRAN, .NET의 NuGet).</p>

<p>벤더링 또는 매니페스트 어떤 방식을 사용하든 가장 중요한 고려사항은 다음과 같습니다.</p>

<ul>
<li><strong>추적 가능성:</strong> 제공된 특정 패키지 또는 배포부터 빌드에 사용된 모든 종속 항목의 정확한 버전까지 추적할 수 있어야 합니다.
그렇지 않으면 종속 항목 변경으로 인한 문제를 디버깅하는 것이 불가능합니다.</li>
<li><strong>재현 가능성:</strong> 빌드 프로세스가 가능한 한 결정적이어야 합니다. 서로 다른 머신에서 서로 다르게 작동하는 빌드 프로세스로 인해 발생한 문제는 디버깅하기에 매우 어려울 수 있습니다.</li>
</ul>

<h3 id="implementing_code_maintainability_at_google" data-text="Google의 코드 유지보수성 구현">Google의 코드 유지보수성 구현</h3>

<p>Google은 비교적 일반적이지 않은 방법을 통해 코드 유지보수성을 구현합니다. 이러한 방식이 장단점이 있고 경우에 따라 적합하지 않을 수도 있지만 이 문서에 기술된 목표를 팀에서 충족하는 데에는 효과적입니다.</p>

<p>전 세계 Google 소프트웨어 개발자 중 95%가 <a href="/architecture/devops/devops-tech-trunk-based-development" track-type="article" track-name="internalLink" track-metadata-position="body">트렁크 기반 개발</a> 모델을 사용하여 중앙화된 소스 제어 시스템을 통해 관리되는 모놀리식 공유 코드베이스로 작업을 진행합니다.
<a href="http://dl.acm.org/citation.cfm?id=2854146" target="external" track-type="article" track-name="externalLink" track-metadata-position="body">2016</a>년, Google 코드베이스에는 '대략 10억 개의 파일이 포함되었으며 Google 창사 이래로 18년 동안 약 3,500만 건의 커밋이 기록되었습니다. 이 저장소에는 900만 개의 고유한 소스 파일에 약 20억 줄의 코드를 비롯하여 86TB 데이터가 포함되어 있습니다.'</p>

<p>모든 Google 코드가 단일 저장소에 보관되기 때문에 다른 팀의 코드를 쉽게 찾고 변경할 수 있습니다. Google은 전체 코드베이스를 쉽게 검색할 수 있게 해주는 내부 검색 엔진을 제공합니다. 개발자는 검토 및 승인을 위해 변경 목록을 만들 수 있게 해주는 다양한 도구를 갖고 있습니다. 모든 변경 목록에 대해 테스트가 실행되고 변경 목록을 업데이트하고 주석을 달 수 있습니다.
다른 많은 플랫폼과 비슷하게 Google의 코드 검토 도구는 특정 변경에 대한 검토자를 제안할 수 있습니다. Google 저장소의 각 디렉터리에는 해당 디렉터리에 있는 파일에 대해 변경을 승인할 수 있는 사람 또는 그룹이 나열된 OWNERS 파일이 있습니다. <a href="https://help.github.com/en/github/creating-cloning-and-archiving-repositories/about-code-owners" target="github" track-type="article" track-name="gitHubLink" track-metadata-position="body">GitHub</a>, <a href="https://docs.gitlab.com/ee/user/project/code_owners.html" target="external" track-type="article" track-name="externalLink" track-metadata-position="body">GitLab</a>, <a href="https://marketplace.atlassian.com/apps/1218598/code-owners-for-bitbucket-server?hosting=server&amp;tab=overview" target="external" track-type="article" track-name="externalLink" track-metadata-position="body">Bitbucket</a>에서도 이와 비슷한 기능이 제공됩니다.
빠른 검색, 승인자 제안, 자동화된 테스트를 통해 변경 제안, 검토, 협업이 모두 직관적이고 강력하게 수행됩니다.</p>

<p>이러한 도구를 사용하면 코드베이스의 여러 부분을 변경하는 대규모 리팩터링도 비교적 쉽게 수행할 수 있으며, 원자적으로 수행될 수 있습니다. Google은 코드베이스의 상당 부분에 영향을 주는 변경 프로세스를 더욱 단순화하고 자동화하는 도구를 만들었습니다. 이러한 Google 도구에는 종속 항목을 포함하여 소스로부터 모든 변경 사항을 빌드하고 테스트하기 위해 사용되는 Blaze라는 빌드 시스템이 있습니다. (Blaze의 일부는 오픈소스 도구인 <a href="https://bazel.build/" target="external" track-type="article" track-name="externalLink" track-metadata-position="body">Bazel</a>의 형태로 출시되었습니다.)
동일한 모놀리식 저장소에서 관리되는 인프라 구성을 포함하여 Google의 누구나 Google의 어느 부분에서든 변경을 쉽게 검색하고 제안할 수 있습니다. 코드 공유 및 재사용이 직관적입니다.</p>

<p>Google은 또한 오픈소스 소프트웨어에서 종속 항목을 관리할 수 있는 방법을 제공합니다. 먼저 Google에서 사용되는 모든 오픈소스 소프트웨어는 Google의 모놀리식 저장소에서 소스 확인을 거쳐야 합니다. 둘째, 언제든 지정된 라이브러리의 한 가지 버전만 소스 제어로 확인될 수 있습니다. 셋째, 모든 소프트웨어가 정적으로 연결되고 소스로부터 빌드됩니다. 마지막으로, 언제든 라이브러리의 소스 코드에 변경이 있으면, 해당 종속 항목을 소비하는 모든 소프트웨어에 대해 리빌드 및 자동화된 테스트가 트리거됩니다.</p>

<p>이러한 제어 방식은 Google의 강력한 CI 인프라와 결합되어 프로덕션 시스템을 새로운 종속 항목 버전으로 쉽게 최신 상태로 유지할 수 있게 해줍니다. 또한 모든 시스템에서 특정 라이브러리 버전이 일관적으로 사용되도록 보장합니다. 공통 라이브러리의 <em>서로 다른 버전</em>이 사용되는 두 구성요소가 제품에 사용되어 제품 빌드를 불가능하게 만드는 '다이아몬드 종속 항목' 상태가 일어날 가능성을 없애줍니다.</p>

<p>외부 코드에 대한 종속 항목 관리를 위한 Google 방식의 단점은 새로운 종속 항목을 추가하는 것이 점점 더 어려워진다는 것입니다(코드 유지보수성의 주요 결과 중 하나). 종속 항목이 새로 추가될 때마다 Google의 모놀리식 저장소에서 소스 코드 확인을 거쳐야 합니다. 즉, 처음과 이후 업그레이드가 있을 때마다 코드를 검토하고 테스트해야 합니다. 하지만 이런 정도의 수고는 Google의 제품에 보안 취약점이 있는 코드가 들어갈 위험을 방지하고 모든 종속 항목에 유지보수 책임자를 명확하게 지정할 수 있게 해줍니다.</p>

<h2 id="common_pitfalls_of_implementing_code_maintainability" data-text="코드 유지보수 구현에 따른 일반적인 문제">코드 유지보수 구현에 따른 일반적인 문제</h2>

<p>모든 사람이 모든 코드를 일반적으로 검색하고 변경할 수 있도록 만들 때의 중요한 장애는 도구 지원과 조직 문화입니다.</p>

<p>첫 번째 일반적인 문제는 액세스 설정이 제한적인 여러 개의 버전 제어 저장소 또는 제어 저장소입니다. 조직은 이상적으로 모든 코드가 보관되는 단일 버전 제어 플랫폼을 가져야 합니다.
기본 액세스 권한으로 조직 내 모든 사람이 모든 소스 코드를 볼 수 있어야 하고, 민감한 파일은 액세스를 제한할 수 있어야 합니다. 또한 버전 제어를 검색할 수 있는 방법도 필요합니다.</p>

<p>반면에 조직은 일반적으로 버전 제어를 변경할 수 있는 사람을 제한합니다. 그 결과 두 번째 문제가 발생합니다. 즉, 자신에게 쓰기 권한이 없는 코드베이스 일부를 변경하려는 사람들을 위한 도구 및 프로세스의 부재입니다. 이는 종종 자신이 사용하는 코드에 대해 다른 팀이 (종종 실수로) 일으킨 문제를 해결하는 데 중대한 장애가 될 수 있습니다. 또한 코드베이스의 여러 부분을 건드리는 리팩터링을 방해합니다.</p>

<p>이 문제를 해결하기 위해 일부 현대적인 버전 제어 도구는 사용자에게 쓰기 권한이 없는 코드베이스 부분에 대해 변경 요청을 제출, 검토, 승인, 감사할 수 있는 방법을 제공합니다.</p>

<p>지원 도구가 있더라도 조직은 조직 내에서 그리고 잠재적으로는 벤더 및 계약업체를 위해서도 코드베이스를 이용 및 검색 가능하도록 만드는 데 불편이 없어야 합니다. 버전 제어 저장소에 상당한 양의 기밀 정보와 팀 간 공유될 수 없는 코드가 포함된 조직은 이것이 가능하지 않을 수 있습니다.</p>

<p>바이너리 종속 항목을 사용하는 것이 훨씬 더 일반적이지만 각 언어마다 바이너리 종속 항목 관리를 위한 고유 도구 모음을 갖고 있습니다. 조직의 전체 소프트웨어 포트폴리오에서 이러한 도구 모음 간에 종속 항목을 효과적으로 관리 및 추적할 수 있게 해주는 표준 전략과 규범을 만드는 것은 매우 복잡한 일입니다. 정기적으로 제3자 라이브러리를 업그레이드하는 프로세스를 추적 가능하게 만들기 위해서는 기존 시스템과의 호환성 및 취약점 확인을 위해 새 버전의 라이브러리를 쉽게 테스트할 수 있게 해주는 CI 인프라에 대한 상당한 투자가 필요합니다.</p>

<p>실제로 대부분의 조직은 팀이 자신의 종속 항목을 관리하도록 맞겨둠으로써 팀 간 편차가 매우 클 수 밖에 없습니다. 따라서 라이브러리에서 취약점이 발견되었을 때 이에 대해 빠르게 예측 가능한 방식으로 대응하는 것이 일반적으로 매우 어려우며, 영향을 받는 해당 서비스를 찾는 것조차 일반적으로 상당히 어려운 일이 됩니다.</p>

<h2 id="how_to_measure_code_maintainability" data-text="코드 유지보수성 측정 방법">코드 유지보수성 측정 방법</h2>

<p>다음은 코드 유지보수성 측정을 시작하는 데 도움이 되는 간단한 개념들에 대한 설명입니다.</p>

<ul>
<li>조직의 코드베이스 중 검색 가능한 비율은 얼마인가요?</li>
<li>쓰기 액세스 권한이 없는 코드베이스 부분을 변경할 때 필요한 선행 시간은 평균 얼마인가요?</li>
<li>코드베이스 중 중복 코드가 있는 비율은 얼마인가요? 미사용 비율은 얼마인가요?</li>
<li>사용되는 모든 라이브러리에 대해 최신 안정 버전을 사용하지 않는 애플리케이션 비율은 얼마인가요?</li>
<li>프로덕션에 사용되는 각 라이브러리 중 버전이 다른 것은 얼마인가요?
중앙 값은 얼마인가요? 유효 목표는 얼마인가요? 1년 이상된 버전은 얼마인가요?</li>
<li>팀의 라이브러리 업그레이드 주기는 얼마인가요? 이를 수행하는 데 걸리는 시간은 얼마인가요?</li>
</ul>

<p>측정 대상을 고려할 때는 세 가지 사용 사례에 주의해야 합니다.</p>

<ul>
<li>기술 및 설계 부채 관리</li>
<li>변경 관리(긴급 변경 포함)</li>
<li>취약점 패치</li>
</ul>

<p>코드베이 성장에 따라 기술 부채가 중요한 관심사입니다. 조직 발전 및 조직 및 해당 고객이 사용하는 제품의 발전에 따라 코드를 리팩터링하고 <a href="/architecture/devops/devops-tech-architecture">재설계</a>할 수 있는 기능이 중요합니다. 대규모 코드베이스의 경우 상당한 도구 지원 없이는 이러한 작업이 매우 복잡하고 어려울 수 있습니다. 또한 사용되지 않는 코드, 중복된 코드, 테스트 성과가 낮은 코드, 취약점이 있는 코드 등을 식별할 수 있는 능력도 중요합니다. 첫 번째 단계는 이러한 도구를 통해 개선 영역이 식별되는 측정항목을 설정 및 추적하고 안전하고 직관적으로 조치를 취할 수 있는지 확인하는 것입니다.</p>

<p>두 번째 단계는 <a href="/architecture/devops/devops-tech-database-change-management">변경 관리</a>입니다.
코드베이스 중 일부가 변경되었을 때 이러한 변경으로 인한 영향을 확인하는 데 도구가 어느 정도까지 도움이 되는지 확인할 수 있어야 합니다. 다른 팀에 영향을 주는 경우에는 특히 문제가 코드베이스의 다른 영역에 존재할 경우 문제 해결을 위한 조치를 얼마나 빠르게 수행할 수 있는지 확인해야 합니다. 긴급 변경이 반드시 필요한 경우, 코드베이스에서 필요한 코드 변경을 적용하고 테스트 및 출시하는 데 얼마나 시간이 걸리는지도 확인해야 합니다.</p>

<p>변경 사항이 프로세스 전체에 전파되는 시간을 추적할 수 있도록 측정항목을 설정하고 추적합니다. 그런 후 병목 지점을 식별하고 필요한 위치에 도구 지원을 추가하여 프로세스를 개선합니다. 빠른 처리를 위해 검사 및 승인을 우회하는 '긴급' 프로세스에 주의해야 합니다. 목표는 일반 프로세스를 신뢰할 수 있게 만들고 긴급 상황에서도 효과적일 수 있도록 충분히 빠르게 만드는 것입니다.</p>

<p>취약점 패치는 특히 중요한 변경 관리 시나리오입니다. 라이브러리에서 취약점이 발견되었을 때 라이브러리의 취약 버전을 사용하는 소프트웨어를 찾고 이를 패치하는 데 걸리는 시간을 확인해야 합니다.
확실하지 않으면 정기적으로 테스트를 수행할 가치가 있습니다. 보안 위반 사고 및 데이터 및 코드 유출을 처리할 때 드는 막대한 비용과 그러한 공격의 빈도를 감안하면, 사용되는 제3자 소프트웨어가 최신 상태인지 확인하고 취약점이 발견되었을 때 이를 쉽게 업그레이드할 수 있도록 상당한 리소스를 투자할 가치가 있습니다.</p>

<h2 id="whats_next" data-text="다음 단계">다음 단계</h2>

<ul>
<li>다른 문서 및 리소스 링크는 <a href="/devops" track-type="solution" track-name="internalLink" track-metadata-position="body">DevOps 페이지</a>를 참조하세요.</li>
<li><a href="https://research.google/pubs/pub45424/" target="external" track-type="article" track-name="externalLink" track-metadata-position="body">Google이 수십억 줄의 코드를 단일 저장소에 저장하는 이유</a></li>
<li><a href="https://www.youtube.com/watch?v=W71BTkUbdqE" target="youtube" track-type="article" track-name="youtubeLink" track-metadata-position="body">Google 모놀리식 코드 저장소에 대한 Rachel Potvin 프레젠테이션</a> </li>
<li>DevOps <a href="https://www.devops-research.com/research.html">연구 프로그램</a>을 살펴보세요.</li>
<li><a href="https://www.devops-research.com/quickcheck.html">DevOps 빠른 점검</a>을 사용하여 업계와 비교되는 자신의 현재 상태를 파악하세요.</li>
</ul>

</body></html>